***** План реализации для сервиса загрузки фото в базу данных *****

1. С помощью интерактивной утилиты (класс PhotoSelector из модуля core.utils.open_new_images) получаем список абсолютных путей до изображений.

2. С помощью команды split выделяем из списка путей названия изображений и добавляем их в новый список.

3. Проверяем не загружены ли какие-то изображения из списка уже в базу данных (на данный момент предлагается использовать метод get_all_image_names из класса ImageDatabase модуля database.database_client_new) и удаляем из обоих списков, если такие были обнаружены.

4. Загружаем названия изображений в таблицу (метод add_new_image из класса ImageDatabase модуля database.database_client_new). Для этого нужно будет взять название фото из списка с названиями изображений, а также сформировать дату с помощью класса datetime в формате  гггг-мм-дд чч:мм:сс. После этого можно уже воспользоваться методом. Таким образом, в таблице будет уже сформирован PhotoID (там стоит autoincrement, поэтому поле заполняется автоматически), название фото и дата добавления в таблицу (её можно использовать как дату и время фото, если окажется невозможно взять их метаданных).Эти три поля имеют атрибут NOT NULL, поэтому обязательно должны быть заполнены. Остальные поля пока что могут оставаться пустыми. Мы их заполним чуть позже.

5. Теперь, после добавления названий фото в таблицу, сами файлы фотографий нужно отправить в архив. Путь до папки: /resources/photo_storage. Для этого необходимо скопировать фотографии используя список абсолютных путей. Очень важно, что фото должны быть скопированы, а не перемещены, так как изображения могут представлять некоторую ценность для пользователя. Реализация уже написана Машей, но, очевидно, её следует несколько подправить, учитывая сказанное выше.

6. На данном этапе новые фото уже скопированы в архив и добавлены в базу данных. Далее предполагается предполается два сценария: первый - дальнейшая загрузка новых фото -> мы возвращаемся к пункту 1, второй - переход к обработке загруженных фото -> переход к пункту 7.

7. В рамках обработки нам необходимо заполнить пустые ячейки в базе данных, что предполает следующие этапы: вычленение из фото основных цветов и добавление в базу данных (пункт 8), получение из фото exif данных - GPS и дату/время создания и добавления их в базу данных (пункт 9), наконец, по местоположению фото и времени/дате создания получение погоды и добавление в базу данных (пункт 10). Скорее всего мне потребуется ещё сделать поиск пустых ячеек в каждой из категорий.

8. С помощью уже готовых функций, которые использовали Ваня и Маша (за которые я не шарю, сорян), нужно извлечь из фото основные цвета (сколько? хороший вопрос! наверное, нужно обсудить и сойтись на чём-то конкретном). Для извлечённых цветов в базе данных создана специальная таблица, которая имеет хитрую связь с основной таблицей с фото (например, вы не можете добавить в таблицу цветов цвет для фото, которой нет в основной таблице, или же, при удалении фото в основной таблице, связанные с ней цвета также будут удаляться). Добавление цветов осущевляется по одному в формате RGB (значения 0-255) с помощью метода add_color из класса ImageDatabase модуля database.database_client_new. Для добавления нового цвета вам также потребуется знать PhotoID из таблицы Photos.

9. Для извлечения метаданных есть функция extract_exif_info_from_image в модуле image_processing.exif_processing, которая возвращает все метаданные, содержащиеся в фото (конечно, если они вообще там есть). Далее с помощью класса GPSInfo в модуле model.image_gps_info и класса DataTimeInfo (здесь неверно, нужно DateTimeInfo) в модуле model.image_datetime_info из exif данных выделяются GPS и дата/время соответственно. Как правильно GPS хранится не виде latitude/longitude, а виде (град, мин, сек) + направление для каждой из осей, поэтому в классе GPSInfo реализовано преобразование из одного вида к другому. Для добавления даты/времени в базу данных есть метод add_datetime из класса ImageDatabase модуля database.database_client_new. На вход требуется PhotoID и дата/время сформированное с помощью класса datetime. В качестве одной из проблем, которые здесь могут возникнуть, это часовой пояс, в котором было сделано фото. Так как в exif данных не содержится время UTC или часовой пояс, то сервис оказывается не работоспособным для пользователей или фото в других часовых поясах. Однако, мы пока что не будем заниматься этим вопросом. Для добавления местоположения в базу данных есть метод add_location из класса ImageDatabase модуля database.database_client_new. На вход требуется PhotoID, а также значения latitude и longitude.

10. Для получения погоды предлагается воспользоваться OpenWeather API, который позволяет получить почасовую погоду за последний год, если известно местоположение и дата/время. Для это существует метод get_history_weather в классе OpenWeatherClient модуля clients.openweather.openweather_client. В качестве показателя погоды на данный момент предполагается использовать только степень облачности, которая варьируется в диапазоне от 0 до 100 (видимо, это проценты). Очевидно, что степень облачности влияет на общую освещенность, а значит и цветовосприятие. Поэтому из ответа, который мы получаем от API, нам нужно взять только значение по ключу "clouds". Это значение вносится в базу данных с помощью метода add_weather из класса ImageDatabase модуля database.database_client_new.

11. Теоретически внесение данных, представленное в пунктах 8-10, может происходить в любой последовательности, однако, как я предполагаю, лучше всего это будет делать в том порядке, в котором я их описывал.
